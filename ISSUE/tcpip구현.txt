아래는 오늘 5시간 동안 진행한 구현·디버깅 이슈를 “처음부터 끝까지” 빠짐없이 회고 형식으로 정리한 기록이다. 기술적 사실, 시도한 변경, 실패/성공 원인, 최종 결론과 후속 과제까지 모두 포함한다. 불필요한 미사여구 없이 사실 위주로 적었다.

⸻

0) 초기 환경/목표
	•	목표
	•	ESP32 클라이언트가 문 열림(OPEN) 시에 무게 측정 → 서버로 데이터 전송 → 문 닫힘(CLOSE) → 클라이언트 우아한 종료
	•	서버는 상시 기동. 클라이언트가 꺼졌다 켜져도 계속 접속 받아 DB에 INSERT.
	•	DB 명세상 WasteRecord.House_ID는 House 테이블의 정수 PK를 참조해야 함.
	•	제약/요구
	•	코드 주석 스타일 유지(중괄호 끝에 // ... end 등).
	•	변수명/로직 임의 변경 금지. 필요 시 “추가만”.
	•	이모티콘 사용 금지.
	•	학생 수준 문법(가능한 단순한 C/Arduino 코드; 고급 MySQL C API 활용 최소화).

⸻

1) 빌드/링킹 시작 이슈 (mysql_config 관련)
	•	문제
	•	$(mysql_config --cflags --libs) 사용 대신 직접 -lmysqlclient 등으로 링크하고 싶다는 요구.
	•	환경변수 PATH/LIBRARY 설정으로 해결 시도.
	•	진행
	•	PATH에 mysqlclient의 include/lib 경로를 추가하고 수동 링크를 지향.
	•	상태
	•	상세 빌드 옵션 합의는 본문에서 핵심 이슈가 아니어서 심층 고정은 안 했고, 이후 서버/클라 로직 디버깅으로 초점 이동.

⸻

2) 서버 바인드 에러
	•	문제
	•	bind() 에러 발생 사례가 보고됨.
	•	원인 후보
	•	포트 사용 중(TIME_WAIT/잔존 프로세스).
	•	SO_REUSEADDR 미설정 혹은 적용 타이밍 문제.
	•	조치
	•	setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); 이미 설정.
	•	포트 충돌 상태 해소 후 정상화 확인.
	•	결론
	•	일시적 환경 문제였고 이후 바인드 정상.

⸻

3) House_ID 파싱/DB 저장 오류
	•	현상
	•	DB 저장 시 “house_id 저장 오류”, “참조키 오류(FK)”, “Data truncated” 류 에러 다수.
	•	근본 원인
	•	클라이언트가 101-902@값 형태로 전송.
	•	서버가 101-902를 그대로 WasteRecord.House_ID에 넣으려 했으나, 스키마상 House_ID는 정수 PK. 문자열 넣으면 FK/자르기 오류 발생.
	•	초기 시도
	•	서버에서 %d → '%s'로 바꾸는 등 문자열로 넣는 변형 시도했지만 스키마와 불일치로 근본 해결 안 됨.
	•	최종 해결 방향
	•	"101-902"를 APT_UNIT='101', APT_NUM='902'로 분해 → House 테이블에서 SELECT House_ID 조회 → 그 정수값으로 WasteRecord에 INSERT.
	•	구현 변천
	1.	MYSQL_RES/mysql_store_result 사용 버전 제안 → “학생 수준 문법” 요구로 거부.
	2.	mysql_use_result 활용 버전 제안 → 역시 고급 API 거부.
	3.	최종안: INSERT 서브쿼리
INSERT INTO WasteRecord (House_ID, ...) VALUES ((SELECT House_ID FROM House WHERE APT_UNIT='101' AND APT_NUM='902'), ...)
이 방식으로 C단에서 결과 가져오지 않고도 FK를 만족하며 저장 가능.
	•	결과
	•	FK/Truncate 오류 해결. DB 저장 경로 안정화.

⸻

4) 클라이언트 동작 모델 논쟁과 정리
	•	클라이언트 동작 요구 명확화
	•	“클라이언트가 open하면 요청 → 무게측정 → 데이터전송 → 닫힘 → 클라이언트 우아한종료 → 다시 오픈하면 켜짐.. 무한반복”
	•	중간 혼선
	•	“연결 유지형(keep-alive) vs 이벤트형(열릴 때만 연결)”
	•	시연 목적 상 “이벤트 기반(열릴 때만 연결/전송/종료)”이 요구사항에 적합.
	•	코드 형태에 대한 요구
	•	함수 분해를 최소화하거나 제거하고, 학생 수준으로 단순화된 통코드 형태 선호.
	•	기존 변수/주석/형식 유지(특히 // ... end 주석).
	•	결론
	•	이벤트 기반 모델 채택:
	•	CLOSE 상태: 대기만.
	•	OPEN 감지: 안정화 딜레이 → 무게 측정 → TCP 연결 → send → shutdown(SHUT_WR) → 서버 FIN 대기 → close() → CLOSE 감지 시 대기 복귀.
	•	이 모델로 클라이언트 구현 정리.

⸻

5) 클라이언트 측 세부 이슈
	•	무게가 안 찍히는 문제
	•	원인
	•	OPEN 검출 직후 곧바로 CLOSE로 전환되면 로드셀 안정화/검출 조건(detectStart >= 1000ms, diff > threshold)을 못 만족.
	•	개선
	•	OPEN 상태 진입 시 1초 안정화 딜레이 부여.
	•	기존 detectStart 논리 유지.
	•	연결 로그 혼선
	•	현상
	•	connect() 실패 로그 후 즉시 재연결 성공하여 “성공/실패 로그”가 섞여 보임.
	•	원인
	•	서버가 accept 타이밍이 늦거나, 클라이언트 재시도 타이밍 이슈.
	•	개선
	•	필요 시 1회 재시도/소폭 딜레이. 다만 최종 코드는 단순성(학생 수준) 우선으로 불필요 재시도 로직은 지양.
	•	함수 사용 문제
	•	요구
	•	함수 분리 최소화(혹은 제거) 및 통짜 흐름 선호.
	•	대응
	•	setup() + loop() 중심, 나머지는 루프 내 직선형 처리로 정리한 버전 제시.
	•	주석/포맷 요구
	•	모든 중괄호 끝에 // ... end 주석 추가한 버전 제공.
	•	이모티콘 제거, 문장체 단순화.

⸻

6) 서버의 세션 운영 모델
	•	문제 제기
	•	서버가 한 번 accept 후 종료되는 구조는 말이 안 됨. 상시 서비스 필요.
	•	최종 구조
	•	while(1) 바깥 루프에서 accept()를 반복 수행.
	•	내부에 클라이언트별 수신 루프.
	•	클라이언트가 종료하면 현재 세션만 정리(shutdown 대기 → close)하고, 다시 accept()로 복귀.
	•	DB 커넥션은 프로세스 수명 동안 유지.
	•	결과
	•	ESP32가 여러 번 켜졌다 꺼져도 언제든 새 연결을 받아 DB에 지속 저장.

⸻

7) 문자열 파싱/보안 관련 메모
	•	하우스 ID 파싱
	•	sscanf(house_id, "%7[^-]-%7s", apt_unit, apt_num); 형태로 과도 입력 방지.
	•	쿼리 안전성
	•	본 과제 범위에서 “학생 수준”을 우선하여 프리페어드 스테이트먼트 미적용.
	•	실제 운영 시엔 mysql_stmt_* 준비문 사용, 이스케이프/검증 필요.
	•	IP 기록
	•	inet_ntoa(clnt_addr.sin_addr)로 실 접속 IP 저장.

⸻

8) 최종 서버 코드(핵심 요지)
	•	상시 기동: 외곽 while(1)에서 accept() 반복.
	•	수신 루프에서 @ 기반 파싱.
	•	INSERT 시 (SELECT House_ID FROM House WHERE APT_UNIT=... AND APT_NUM=...) 서브쿼리로 PK 자동 조회.
	•	세션 종료는 우아한 종료:
	•	shutdown(clnt_sock, SHUT_WR) → FIN 대기 read(...)==0 → close(clnt_sock).

⸻

9) 최종 클라이언트 코드(핵심 요지)
	•	문 열림 감지 기준: 초음파 평균값 d >= 6 유지 1초.
	•	OPEN 상태 진입 시 로드셀 기준값 보정, 안정화 후 무게 변동 감지.
	•	감지되면 그 시점에 TCP 연결 생성 → send → shutdown(SHUT_WR) → 서버 FIN 대기 → close().
	•	CLOSE 상태에선 연결하지 않고 대기.
	•	루프는 계속 반복.

⸻

10) 남은 리스크/권장 후속 작업
	•	데이터 무결성
	•	House 테이블에 (APT_UNIT, APT_NUM) 유니크 보장 필요(중복 시 서브쿼리 다중행 문제).
	•	에러 처리 강화
	•	서버: INSERT ... SELECT가 NULL 반환되는 경우 에러 메시지 명확화.
	•	클라: connect() 실패 시 1~2회 재시도 및 백오프 권장.
	•	안정화 파라미터
	•	초음파 문턱값 6, 로드셀 임계값 threshold=0.05, 안정화 시간 1000ms는 현장 캘리브레이션 필요.

⸻

11) 최종 결론
	•	DB 스키마 불일치(문자열 House_ID vs 정수 FK)로 인해 발생했던 저장 오류는, 서버에서 하우스 문자열을 (APT_UNIT, APT_NUM)로 분해하여 서브쿼리로 정수 PK를 직접 삽입하는 방식으로 해결되었다.
	•	클라이언트는 이벤트 기반(OPEN 시 1회 연결/전송/우아한 종료, CLOSE 시 대기)으로 정리했다.
	•	서버는 무한 루프에서 accept()를 반복하여 상시 서비스하도록 정리했다.
	•	주석 스타일, 변수명, 이모티콘 금지, 학생 수준 문법 요구사항을 준수했다.
	•	현 시점에서 OPEN 이벤트마다 DB에 정상 INSERT가 가능한 상태이며, 연결/종료도 명시적으로 우아하게 처리된다.

이상으로, 오늘 진행한 전 과정의 이슈와 수정·결론을 빠짐없이 정리했다.